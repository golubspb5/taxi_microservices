### Декомпозиция и план разработки на 1 месяц (4 недели)

**Общие принципы:**
*   **Недельные спринты:** План разбит на 4 недели. В конце каждой недели — короткая синхронизация для демонстрации результатов и планирования следующей.
*   **API-First:** Бэкенд-разработчики в первую очередь фокусируются на реализации и документировании API-контрактов. Это позволит фронтендеру быстрее начать интеграцию, используя mock-данные.
*   **Параллельная работа:** Задачи для бэкенд-разработчиков подобраны так, чтобы минимизировать блокировки и зависимости друг от друга.

---

### **Роли:**

*   **Backend-разработчик 1 (Core & Orders):** Ответственен за ядро системы, аутентификацию, и полный жизненный цикл заказа.
*   **Backend-разработчик 2 (Real-time & Drivers):** Ответственен за все, что связано с водителями в реальном времени: их статус, геолокацию, а также за сложную логику подбора и уведомлений через WebSocket.
*   **Frontend-разработчик:** Ответственен за создание двух ключевых интерфейсов (пассажира и водителя) и их интеграцию с бэкендом.

---

### План по неделям

### **Неделя 1: Фундамент и базовые сущности**

**Цель недели:** Развернуть окружение, создать базовую структуру приложения, реализовать аутентификацию и управление состоянием водителя.

---

#### **Backend-разработчик 1 (Core & Orders)**

1.  **Настройка проекта:** Инициализировать структуру FastAPI-приложения. Настроить `pydantic-settings` для конфигурации.
2.  **Настройка базы данных:** Создать базовые модели SQLAlchemy (`users`, `drivers`, `passengers`) на основе схемы в `README.md`. Настроить `alembic` для миграций.
3.  **Реализация User Service:** Создать эндпоинты для регистрации и логина (`POST /api/v1/auth/login`), реализовать JWT-аутентификацию и базовые Pydantic-схемы для пользователей.
4.  **Создание заготовок:** Подготовить пустые, но рабочие эндпоинты для `rides` с "заглушками", чтобы фронтенд мог начать работу.

#### **Backend-разработчик 2 (Real-time & Drivers)**

1.  **Настройка Redis:** Создать сервисный слой для работы с Redis (подключение, простые операции).
2.  **Реализация Driver Profile Service:** Полностью реализовать эндпоинт `PUT /api/v1/drivers/me/presence`.
3.  **Логика геоиндекса:** Написать функции для обновления местоположения водителя в Redis (используя `HSET "cell:X:Y" ...` как описано в архитектуре).
4.  **Написание тестов:** Написать unit-тесты для сервиса обновления статуса водителя.

#### **Frontend-разработчик**

1.  **Настройка проекта:** Инициализировать React-приложение (например, через `create-react-app` или `vite`), настроить роутинг (`react-router-dom`).
2.  **Создание UI-компонентов:** Разработать базовые компоненты: кнопки, поля ввода, лэйаут.
3.  **Реализация страниц:** Создать страницы: главную, входа, регистрации. Реализовать формы и базовую валидацию.
4.  **Интеграция с Auth API:** Интегрировать формы с эндпоинтами аутентификации, реализовать сохранение JWT-токена (в `localStorage` или `sessionStorage`).

---

### **Неделя 2: Основная бизнес-логика**

**Цель недели:** Реализовать ключевой сценарий — создание заказа и его асинхронную обработку для поиска водителя.

---

#### **Backend-разработчик 1 (Core & Orders)**

1.  **Реализация Pricing Service:** Создать сервис для расчета цены и ETA по формулам из `README.md`.
2.  **Реализация Order Service:** Реализовать эндпоинт создания заказа `POST /api/v1/rides`.
3.  **Интеграция с брокером:** При создании заказа публиковать событие `OrderCreated` в Redis Streams.
4.  **Обновление моделей:** Добавить модель `rides` в SQLAlchemy и создать для нее миграцию.

#### **Backend-разработчик 2 (Real-time & Drivers)**

1.  **Реализация Driver Matching Service (часть 1):** Написать consumer'а для Redis Streams, который слушает события `OrderCreated`.
2.  **Логика поиска водителей:** Реализовать алгоритм поиска ближайших водителей (поиск по спирали в геоиндексе Redis).
3.  **Логика блокировки:** Реализовать механизм атомарной блокировки водителя (`SET driver_lock:{driver_id} ... NX EX`).
4.  **Детерминированное правило:** Реализовать правило выбора водителя при равенстве расстояний (например, по наименьшему ID).

#### **Frontend-разработчик**

1.  **Кабинет пассажира:** Создать интерфейс, где пассажир может ввести начальные и конечные координаты и увидеть расчетную цену и ETA (запрос к API бэкенда).
2.  **Создание заказа:** Реализовать отправку запроса на создание поездки.
3.  **Кабинет водителя:** Создать интерфейс, где водитель может переключать свой статус (`online`/`offline`) и указывать текущие координаты.
4.  **Интеграция с Presence API:** Интегрировать кабинет водителя с эндпоинтом `PUT /api/v1/drivers/me/presence`.

---

### **Неделя 3: Связываем все воедино (Real-time)**

**Цель недели:** Обеспечить real-time взаимодействие между системой и клиентами через WebSocket.

---

#### **Backend-разработчик 1 (Core & Orders)**

1.  **Управление статусами поездки:** Реализовать эндпоинты для водителя `POST /api/v1/rides/{id}/accept` и для обоих `PUT /api/v1/rides/{id}/status`.
2.  **История поездок:** Реализовать эндпоинт `GET /api/v1/users/me/rides`.
3.  **Публикация событий:** Добавить публикацию событий `DriverAssigned`, `RideCompleted` в Redis Streams, чтобы другие сервисы (включая Notification Service) могли на них реагировать.

#### **Backend-разработчик 2 (Real-time & Drivers)**

1.  **Реализация Notification Service:** Создать WebSocket-менеджер и эндпоинт `ws://.../ws`.
2.  **Логика подписок:** Реализовать механизм, который связывает `user_id` с активным WebSocket-соединением.
3.  **Интеграция с Matching Service:** После нахождения и блокировки водителя, Matching Service должен через Notification Service отправить ему предложение о поездке.
4.  **Обратная связь:** Notification Service должен слушать события из Redis Streams (например, `DriverAssigned`) и отправлять соответствующие уведомления пассажиру.

#### **Frontend-разработчик**

1.  **Настройка WebSocket:** Установить и настроить клиентскую библиотеку для работы с WebSocket.
2.  **Real-time уведомления для водителя:** Реализовать логику получения предложения о поездке. Должен появляться UI-элемент (например, модальное окно) с информацией о заказе и кнопками "Принять" / "Отклонить".
3.  **Real-time обновления для пассажира:** После создания заказа, страница пассажира должна в реальном времени отображать изменение статуса ("Поиск водителя", "Водитель назначен", "Водитель в пути" и т.д.).
4.  **Интеграция с Ride API:** Подключить кнопки "Принять", "Завершить", "Отменить" к соответствующим API-эндпоинтам.

---

### **Неделя 4: Тестирование, отладка и подготовка к демо**

**Цель недели:** Стабилизировать приложение, провести сквозное тестирование и подготовиться к демонстрации.

---

#### **Backend-разработчик 1 (Core & Orders)**

1.  **Интеграционное тестирование:** Совместно с Backend 2 написать тесты для полного цикла заказа.
2.  **Документация API:** Проверить и дополнить авто-генерируемую документацию OpenAPI (Swagger/ReDoc) в FastAPI. Добавить описания ко всем эндпоинтам.
3.  **Рефакторинг и отладка:** Провести ревизию кода, исправить найденные баги.

#### **Backend-разработчик 2 (Real-time & Drivers)**

1.  **Обработка "отказ/таймаут":** Реализовать логику, при которой, если водитель не ответил или отказался, блокировка с него снимается, и система ищет следующего.
2.  **Нагрузочное микро-тестирование:** Написать простой скрипт для проверки производительности эндпоинта `presence` и поиска водителей в Redis.
3.  **Логирование:** Добавить осмысленное логирование ключевых событий (создание заказа, поиск водителя, отправка уведомления).

#### **Frontend-разработчик**

1.  **Отображение истории поездок:** Создать страницу и UI для отображения списка прошлых поездок.
2.  **UI/UX полировка:** Улучшить интерфейс, добавить обработку ошибок (например, "Не удалось найти водителя"), индикаторы загрузки.
3.  **Сквозное тестирование:** Протестировать все пользовательские сценарии от начала до конца совместно с бэкенд-разработчиками.
4.  **Подготовка демо-сценария:** Подготовить и отрепетировать демонстрацию ключевых фич.